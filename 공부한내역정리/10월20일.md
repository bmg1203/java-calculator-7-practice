# 10월 20일 공부 내용

---
1. 캡술화를 적용한 이유 
   - 내부 구현의 보호:
     - 데이터나 메서드가 외부에서 직접 접근되지 않도록 막는 역할. 
     - StringCalculator 클래스의 내부 메서드들은 데이터를 가공하거나 계산을 해야합니다! 
     - 그만큼 중요한 로직을 포함하고 있습니다. 
     - 이렇나 메서드들에 직접 접근하게 되면 데이터가 잘못들어 올 수 있고, 무결성이 손상됩니다.
   - 로직 변경에 대한 독립성을 위해 :
     - 클래스 내부 구현을 바꾸더라도 외부에서 사용하는 코드에는 영향을 주지 않도록 했습니다. 
     - 내부 로직을 캡슐화함으로써, 로직의 변경이 필요할 때도 해당 클래스만 수정하면 되므로 유지보수 용이
     
   - 응집도 높이기 
     - 클래스 책임을 명확히 했습니다. 
     - 어떤 역할을 하는지 명확하게 했고, 
     - 외부에서는 클래스가 제공하는 메서드들을 사용해 필요한 기능을 수행하지만, 복잡한 처리 과정은 숨겨져 있습니다.
     - 캡슐화는 데이터와 메서드를 은닉하여 안전하게 관리하고, 
     - 외부에서 발생할 수 있는 잘못된 접근을 방지
     - StringCalculator의 내부 메서드 중 getCustomValues나 getIntegers는 특정한 방식으로 데이터를 
     - 가공하기 때문에 잘못된 방식으로 호출하게 되면 오류가 발생할 수 있습니다.


2. Exception을 Custom해서 사용한 이유 
   - 전부 IllegalArgumentException을 처리해야하기 때문에 응집성을 높여 모아서 재사용하면 어떨까? 라는 생각에서
   - 출발했습니다. 
   - 그 이유를 확실히 하고싶었고, 네이밍을 통한 메세지 전달을 확실히 판단하기 쉽게 생각해봤을때 좋아보였습니다. 
