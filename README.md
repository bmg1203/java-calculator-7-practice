# java-calculator-precourse

## 문자열 덧셈 계산기 기능 목록

### 1. 기본 기능

- **입력 처리**: 사용자로부터 문자열을 입력받아야 한다.
  - `camp.nextstep.edu.missionutils.Console`의 `readLine()` 메서드를 사용하여 사용자 입력을 받는다.

- **빈 문자열 처리**: 빈 문자열 입력 시, 결과로 0을 반환해야 한다.
  - 예: `""` => `0`

- **기본 구분자 사용**: 쉼표(,) 또는 콜론(:)을 구분자로 사용하여 숫자를 추출하고 더한다.
  - 예: `"1,2"` => `3`
  - 예: `"1,2,3"` => `6`
  - 예: `"1,2:3"` => `6`

### 2. 커스텀 구분자 기능

- **커스텀 구분자 인식**: 문자열의 시작 부분에 "//"가 있을 경우, 그 뒤의 문자(구분자)와 "\n" 사이에 위치한 문자를 커스텀 구분자로 사용한다.
  - 예: `"//;\n1;2;3"` => 세미콜론(;)을 구분자로 사용하여 `6`을 반환한다.

### 3. 오류 처리 및 출력 구현

- **잘못된 입력 처리**: 잘못된 값을 입력한 경우 `IllegalArgumentException`을 발생시킨다.
  - 음수를 입력한 경우: `"1,-2"` => `IllegalArgumentException("음수는 허용되지 않습니다: -2")`
  - 숫자가 아닌 값을 입력한 경우: `"1,a"` => `IllegalArgumentException("숫자가 아닌 값이 포함되었습니다: a")`


- **결과 출력**: 계산된 결과를 콘솔에 출력한다.
  - 예: `"결과 : 6"`

### 5. 프로그래밍 요구 사항

- **JDK 버전**: JDK 21 버전에서 실행 가능해야 한다.
- **메인 메서드**: 프로그램의 시작점은 `Application` 클래스의 `main()` 메서드여야 한다.
- **외부 라이브러리 제한**: 제공된 라이브러리 외에 추가적인 외부 라이브러리는 사용하지 않는다.
- **시스템 종료 처리**: 프로그램 종료 시 `System.exit()`를 호출하지 않는다.
- **코드 컨벤션 준수**: Java Style Guide를 따라 코드를 작성해야 한다.

### 6. 커밋 전략

- 각 기능 구현 후 Git 커밋을 수행한다.
- 기능이 완성될 때마다 README.md에 기능 목록을 업데이트하고, 그에 맞는 커밋 메시지를 작성한다.

---

# 배움의 내용

## 1. 개행문자 이스케이프 시퀀스 설정에 대한 시행착오

**(1) Pattern.compile() 메소드에서 이스케이프 시퀀스 처리**  
처음에는 정규 표현식을 이용해 입력 문자열에서 커스텀 구분자를 추출할 때, `Pattern.compile("//(.*?)\n")`과 같은 형식을 사용하려 했다. 하지만 자바에서 `\n`이 실제 개행 문자로 인식되어 의도한 동작을 수행하지 못했다. 이를 해결하기 위해 `\\n`을 시도했으나, 자바의 정규 표현식에서는 한 번 더 이스케이프 처리가 필요하다는 사실을 알게 되었다. 결국, 정규 표현식에서 `\\\\n`을 사용하여 문자열 내에서 정확하게 개행 문자를 구분자로 인식할 수 있었다.

**(2) String.split() 메소드에서 이스케이프 시퀀스 처리**  
`input.split()` 메소드를 사용해 문자열을 분리할 때도 유사한 문제를 경험했다. 처음에는 `\n`을 구분자로 사용하려 했으나, 이 역시 실제 개행 문자로 처리되어 원하는 구분자로 인식되지 않았다. 이후 `\\n`을 사용했지만, 자바의 문자열 처리에서 이것은 불완전한 이스케이프 처리였다. 최종적으로 `\\\\n`을 구분자로 사용하여 입력된 문자열의 커스텀 구분자를 정확하게 인식하고 처리할 수 있었다. 이는 정규 표현식과 문자열 처리 방식 모두에서 이스케이프 시퀀스에 대한 깊이 있는 이해가 필요하다는 점을 배울 수 있었던 부분이었다.

## 2. 클린 코드 및 리팩토링 과정에서의 단일 책임 원칙 적용

구현 과정 중 여러 기능을 하나의 함수가 담당하는 구조를 피하고, 단일 책임 원칙을 준수하여 각 기능을 명확하게 분리하는 리팩토링을 진행하였다. 기존의 `calculateSum()` 함수는 입력을 처리하고, 구분자를 결정하며, 숫자를 더하는 모든 기능을 담당하고 있었다. 이를 개선하기 위해 입력을 처리하는 함수는 따로 두고, 구분자를 판별하는 함수 `determineDelimiter()`, 커스텀 구분자가 있는지 확인하는 `hasCustomDelimiter()`, 그리고 구분자를 추출하는 `extractCustomDelimiter()`로 세분화하였다.

특히, 구분자 처리와 관련된 부분은 독립된 함수들로 분리함으로써 각 함수가 하나의 역할만 수행하도록 설계하였다. 이를 통해 코드는 더 명확해졌고, 각 함수의 목적이 명료해져서 유지보수 및 확장성이 높아졌다. 단일 책임 원칙을 적용함으로써 코드의 복잡성을 줄이고, 재사용성을 높이는 데 주력하였다.

## 3. Git과 GitHub 첫 사용 경험

처음에는 깃이라는 이름은 들어봤으나 실제로 사용해본 경험은 전혀 없었다. 프로그래밍 과정에서 Git의 fork() 기능을 사용하여 특정 리포지토리의 복사본을 내 계정으로 가져온 경험이 매우 유익하였다. fork()를 통해 원본 프로젝트에서 독립적으로 작업할 수 있으면서도, 다른 개발자들과 협업을 통해 새로운 기능을 추가하거나 수정할 수 있는 편리함을 경험하였다. 특히, 원본 프로젝트의 변경 사항을 쉽게 반영할 수 있다는 점이 매우 유용하였다. 이를 통해 안전하고 유연한 환경에서 개발할 수 있는 기회를 제공받게 되었다.

인텔리제이 환경에서 수정 내용을 커밋하고 푸시하는 과정을 통해, 커밋은 코드 변경 내용을 기록하여 버전 관리를 수행하는 방법이며, 푸시는 로컬 저장소의 변경 내용을 원격 저장소에 반영하는 작업이라는 점을 알게 되었다. 이러한 구체적인 원리를 이용하여 각 수행 과정을 구조화하는 경험을 통해 이전 프로그래밍 경험에서의 부족함과 개선점을 깨닫게 되었다.

특히, fork, commit, push 기능을 통해 원격 저장소를 활용하는 방법과 편리함을 깨달았고, 코드 변경 내용을 체계적으로 기록하는 과정은 팀원들과의 코드 리뷰를 통해 코드의 품질을 높이는 데 중요한 역할을 한다는 사실을 인식하게 되었다.