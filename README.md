# java-calculator-precourse

## 1주차 - 문자열 덧셈 계산기

* * *  

### 기능 요구 사항 생각해보기

프로그램의 흐름도는 다음과 같다  
> 시작 -> (문자열 입력) -> (문자열 확인) -> (문자열 유효 검사) -> (문자열 파싱) -> (계산) -> (결과 반환) -> 종료  
  
  
  

##### 계산을 담당하는 클래스 Calculator  
* Calculator 클래스는 입출력을 담당하는 클래스로, 이는 입력 받은 문자열과 출력할 결과가 멤버 변수로 있는 클래스이다.  
* 이 클래스의 멤버 변수는 위조 방지를 위해 private이고, 각각 입력과 출력만 하면 되기 때문에 입력은 getter, 출력은 setter 메소드로 구현한다.  
  
  
##### 문자열이 유효한지 검사하는 ContentInsepector
* 문자열에 잘못된 구분자가 있는지를 검사한다.  
* 또한 커스텀 구분자를 추가해야하는 경우, 이를 추가하기 위한 메소드 또는 클래스를 만든다

##### 문자열을 파싱하는 클래스 ContentParser
* ContentInspector로 유효한 문자열인지를 확인한 이후, 이를 배열로 나누는 역할을 한다
* 파싱된 값을 저장하기 위한 배열과 문자열을 파싱하고 반환하는 메소드가 필요하다

* * *
### Test Case 생각해보기
1. 정상적으로 작동하는 사례
	- delimeter ,와 :로만 이루어진 문자열
	- delimeter ,와 :가 혼합되어 사용된 문자열
	- 커스텀 구분자를 올바르게 추가한 문자열(Test Case 1번)  

2. 음수 및 0이 입력된 경우
	- 음수와 0은 문제에서 주어지는 값이 아니다
	- 이를 별도로 처리하는 과정은 ContentInspector에서 음수의 부호를 가지고 있는 경우를 제거하거나 ContentParser에서 파싱된 배열을 검사하는 클래스나 메서드를 만들어서 검사(ParsedContentInsepector)

3. 커스텀 구분자의 형식이 맞지 않는 경우 
	- 커스텀 구분자의 형식이 아닌 경우 (//(delimeter)\n) 이는 예외 처리해야한다
	- 커스텀 구분자를 추가하는 메서드 또는 클래스에서 아닌 경우에 예외 처리

4. 커스텀 구분자 형식 사이에 여러 문자가 껴있는 경우
	- 기본으로 주어진 test case와 같이(//;\\n, ;\이 사이에 껴있다) 여러 문자가 껴 있는 경우
	- 문제에서 주어진 조건에서는 ** 문자 ** 를 추가한다고 했기에 여러 문자가 왔다면 이것을 각각 구분자로 추가해야한다.
5. null, 공백이 입력된 경우
	- 기능 요구 사항에서 처리해야하는 예시로 "" => 0을 제시
	- 이는 파싱된 배열에 원소가 추가되지 않는다면 Calculator의 멤버변수의 변동이 없이 반환되어 결과가 0이 나오는 것으로 해석
6. 구분자가 문자열 맨 앞 또는 맨 뒤에 오는 경우
	- 파싱의 목적으로 사용할 java의 내부라이브러리의 Parse 메서드의 경우 이의 반환type은 wrapper class인데, 이는 null값을 받을 수 있다.
	- ~~그러나 wrapper을 언박싱 할때 null 객체의 경우 이것이 참조하는 값이 없기에 언박싱 과정에서 nullPointerException 발생, 예외처리가 필요하다.~~
	- 그러나 5번 케이스와 같이 null값이 들어온 경우, 이를 0으로 반환하기에 언박싱 과성에서 nullPointerException이 아닌 이를 0으로 처리해야한다.
7. 구분자가 연속으로 쓰인 경우
	- ~~이 역시 6번 테스트케이스와 마찬가지로 구분자가 연속으로 쓰이면 그 사이에서 생성되는 객체는 null이다. 그렇기에 이 역시 마찬가지로 예외처리를 해야한다~~
	- 이 역시 마찬가지로 6번 케이스와 같이 구분자 사이의 값은 0으로 처리한다.
8. 큰 수 연산이 필요한 경우
	- 입출력 요구 사항의 경우 입력 조건은 양수로 구성된 문자열인데, 이는 다시 말하면 결과의 하한선은 0이지만, 상한선은 무제한이라는 결과로 해석할 수 있다.
	- 그렇기에 큰 수가 입력으로 들어왔을 경우, 이를 integer type또는 long type으로 계산시 overflow가 발생할 수 있다.
	- 따라서 출력할 값은 java.math 라이브러리의 BigInteger를 통해 담을 수 있다.
