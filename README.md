# java-calculator-precourse
## 기능 목록
- [X] **입력 문자열 확인**
  - [X] 입력받은 문자열이 비어있는지 확인한다.
  - [X] 비어있으면 0 반환
- [X] **커스텀 구분자 파싱**
  - [X] 입력 문자열이 커스텀 구분자를 포함하는 형식인지 확인한다.
    - [X] 문자열의 시작이 "//"로 시작하고 "\n"이 있는 경우, //와 \n 사이의 문자를 커스텀 구분자로 파싱한다.
    - [X] 커스텀 구분자가 없는 경우에는 기본 구분자인 쉼표(,)와 콜론(:)을 사용하여 숫자를 분리한다.
  - [X] 문자열을 분리하여 각각의 숫자 요소로 만든다.
- [X] **숫자 합산**
  - [X] 분리된 숫자들은 합산하고 결과 값을 반환한다.
- [X] **숫자 유효성 검사**
  - [X] 분리된 각 요소가 숫자인지 확인한다.
  - [X] 숫자가 아닌 값이 있거나, 잘못된 형식의 값이 있을 경우 IllegalArgumentException을 발생시킨다.
## 잘못된 형식의 입력 예외 처리
- [X] 잘못된 형식의 입력 예외 처리
  - [X] **음수 입력 처리**:
    * 목적: 음수 값이 입력될 경우 예외가 발생하는지 확인.
    * 입력: `"1,-2,3"`
    * 예상 동작: `IllegalArgumentException` 발생
  - [X] **숫자가 아닌 값 입력 처리**:
    * 목적: 입력에 숫자가 아닌 값이 포함될 때 예외가 발생하는지 확인.
    * 입력: `"1,A,2"`
    * 예상 동작: `IllegalArgumentException` 발생
  - [X] **잘못된 구분자 형식 처리**:
    * 목적: 잘못된 구분자 형식이 있을 때 예외가 발생하는지 확인.
    * 입력: `"1,,2"`, `"1;\n2"`
    * 예상 동작: `IllegalArgumentException` 발생
## 테스트 계획
- [X] **빈 문자열 입력 테스트**
    * 목적: 입력이 빈 문자열일 때, 0을 반환하는지 확인
    * 테스트 입력: ""
    * 기대 출력: 0
- [X] **쉼표와 콜론 혼용 테스트**
    * 목적: 쉼표(,)와 콜론(;)을 혼용했을 때, 숫자를 올바르게 분리하여 합산하는지 확인한다.
    * 테스트 입력: "1,2:3"
    * 기대 출력: 6
- [X] **커스텀 구분자 테스트**
    * 목적: 커스텀 구분자가 있을 때, 올바르게 처리하는지 확인
    * 테스트 입력: "//[###]\n1###2###3"
    * 기대 출력: 6
- [X] **음수 입력 테스트**
    * 목적: 음수 값이 입력될 경우 예외가 발생하는지 확인한다.
    * 테스트 입력: "1,-2,3"
    * 기대 동작: IllegalArgumentException 발생
- [X] **숫자가 아닌 값 입력 테스트**
    * 목적: 입력에 숫자가 아닌 값이 포함될 때 예외가 발생하는지 확인한다.
    * 테스트 입력: "1,A,2"
    * 기대 동작: IllegalArgumentException 발생
## 고민 한 점
이번 프로젝트에서 검증 로직을 별도의 서비스로 분리할지에 대해 고민이 있었습니다. 
처음에는 검증 로직을 분리하는 것이 더 깔끔하고 SRP(단일 책임 원칙)에 맞는 구조라고 생각할 수 있었지만, 검토 결과 검증 로직을 서비스로 따로 분리하지 않기로 결정했습니다.

첫째로, 검증 로직이 비즈니스 로직과 밀접하게 연관되어 있다는 점을 고려했습니다. 
검증 로직은 해당 클래스의 비즈니스 로직에 자연스럽게 녹아들어 있으며, 이를 분리하는 것이 오히려 클래스 간의 불필요한 복잡성을 증가시키는 결과를 낳을 수 있다고 판단했습니다.

둘째로, 검증 로직을 분리하게 되면 구조가 지나치게 복잡해질 가능성이 있었습니다. 
프로젝트 규모가 크지 않고, 검증 로직이 자주 변경되거나 다양한 곳에서 재사용될 가능성이 낮기 때문에, 검증 로직을 따로 분리하기보다는 해당 클래스 내부에서 처리하는 것이 더 간결하고 직관적이라고 느꼈습니다.

마지막으로, 변경 가능성이 적은 부분에 대해 굳이 복잡한 구조를 도입할 필요는 없다는 결론을 내렸습니다. 
검증 로직을 따로 분리할 경우, 코드의 흐름이 분산되어 유지보수성이 저하될 수 있다는 우려도 있었습니다.

이러한 이유들로 검증 로직을 클래스 내부에 포함시키는 방식을 선택하게 되었으며, 이는 현재 프로젝트의 규모와 요구사항에 더 적합한 구조라고 판단했습니다.
