# 리팩토링
> 리팩토링은 작은 개선 사항부터 시작
> - 불필요한 import 제거, 네이밍 변경 등 작은 부분부터 시작한다
> - 리팩토링은 버그를 고치는 행동이 아니다, 이전과 동일하게 동작하면서 진행하는 것이 리팩토링이다
> - 리팩토링을 후 성공 테스트 코드가 실패하면 리팩토링을 잘못 하고 있는 것  

## Layered Architecture 도입?
- 현재 미션에 Layered Architecture, 기본 레이어를 도입?
- 기본 레이어: Presentation Layer(view, controller) -> Business Layer(service) -> Implement Layer -> Data Access Layer
  - Presentation 계층은 뼈대가 존재, 현재 구현한 `Controller`는 Presentation 계층 코드가 아님
  - Business 계층을 도입할 것인가, 현재 구조는 domain에서 핵심 로직들을 처리하고 `Controller`가 service 역할을 하는 중
  - 데이터 접근 계층은 필요 없음
- 계층형 아키텍처에 대한 학습이 필요
  - MVC 포함
- 현재 `OutputView`가 핵심 도메인인 `PositiveNumber`를 알고 있음 -> DTO 필요

## 개념과 격벽
- 현재의 개념과 격벽에 대한 구조도를 한번 그려 볼 필요가 있음
- 덧셈은 누구의 책임인가? 별도의 계산기가 책임을 가져야 하나? 양수들이 서로를 더해야 하나?
- 구분자를 분리해 1급 개념으로 올릴 것인가? 기본 구분자(1급 개념), 커스텀 구분자(1급 개념)
- 입력을 분리하는 것은 누구의 책임인가? 구분자 자체에서 진행해야 하나? 별도의 분리기 개념이 필요하나?

## 리팩토링 필요 판단 근거
- 작성한 코드에 대한 근거가 존재하는가?
  - 왜 생성자 대신 정적 팩토리 메서드를 썼는지 근거가 있나?
  - 왜 `enum`로 관리하지 않고 메서드 내 상수로 쓰고 있나?
  - 메서드 이름만으로 어떤 기능을 하는지 충분하나?
- 문자열과 숫자는 무조건 상수로 만들어야하나?
  - 상수일 필요가 있나?
  - 상수로 만드는 이유는? -> 상수로 만들지 않아도 어떤 역할을 하는지 드러나나?
- 도메인 로직이 외부로 유출되고 있는가?
  - 테스트 코드, 도메인 계층 외부로 도메인 로직이 유출되고 있는지 확인한다
  - 위 계층이 도메인을 몰라야 한다
- 변경을 예상하지 않는다. 그저 변경이 발생하면 수용할 수 있는 유연함을 담는다
  - 뺄셈, 곱셈, 나눗셈이 추가된다면 빠르게 수용할 수 있을까?
- 사용자 입력을 받을 때 `null`은 언제 발생할까?
  - 사용자가 잘못된 형식의 데이터를 입력하는 경우 발생 가능 -> 입력에서는 공백만을 잘못된 형식으로 보고 예외를 던진다
  - 요청을 전달하면서 필요한 데이터를 누락하는 경우 발생 가능 -> final 로 누락되지 않게 만든다
  - DTO 사용 시 데이터를 누락하는 경우 발생 가능 -> record 사용해 누락을 막는다
  - Scanner의 nextLine() 사용하는 Console 에서 null을 반환하는 상황이 발생할까? nextLine()은 NoSuchElementException 던짐
  - ApplicationTest.run() 메서드는 args를 개행문자 `\n`를 String.join()으로 연결, 즉 `"args[0]\nargs[1]\n"` 처리
  - 원인 불명의 null이 발생해 Objects.requireNonNull()에서 NPE가 터진 경우 `IllegalArgumentException`을 던져야 할까?
  - `IllegalArgumentException`를 던지면 디버깅이 어려움 -> 현재 프로젝트에서 NPE가 발생하면 데이터 누락같은 실수일 확률이 높음
- 역할, 책임, 협력
  - 숫자가 양수인지 판단하는 것은 누구의 책임인가? InputView 가 입력이 양수인지 판단?
  - 빈 문자열이 들어오면 객체지향 세계의 양수 "0"으로 판단해 "0"을 돌려준다고 가정한다면
  - 자율적인 객체 `PositiveNumber`의 책임에 침범한다, 빈 문자열을 양수로 판단하는 책임은 `PositiveNumber`에게
  - 그렇다면 구분자가 split 후 양수인지 판단한다? 이것도 `PositiveNumber`의 책임을 침범, 구분자는 구분자만 판단하고 split
  - 구분자는 해당 구분자가 객체지향 세계에 맞는지 판단만 한다. "//;\n1+2+3" -> 커스텀 구분자가 맞네 -> split 한 결과가 "[1+2+3]"
     -> "[1+2+3]"양수인지 아닌지는 구분자가 판단할 내용이 아님

## 리팩토링 절차
- 리팩토링은 작은 단위에서 시작한다
1. 변수(+ 상수), 메서드, 클래스 이름이 적절한가?
2. 메서드가 어떤 행동을 하고 있는지 한눈에 유추 가능한가?
3. 반복되는 코드가 존재하나?
4. 적절한 책임을 갖고 있나? 너무 많은 책임을 갖고 있나?
   - 개념에서 파생되는 개념이 많나?
   - 개념과 어울리지 않는 행동을 하고 있나?
   - 개념을 상태와 행동으로 착각했나?
   - 상태와 행동을 개념으로 착각했나?
