# 수정 사항

### 10/16

#### 문제점

* ```//;\n1;2;3``` 값을 입력했을 때, ```NumberFormatException: 올바른 숫자 형식이 아닙니다.``` 예외처리 발생.

#### 분석

* StringParser 클래스

~~~
private List<String> parseCustomStrings(String inputStrings) {
        String[] customStrings = inputStrings.split(extractCustomDelimiter(inputStrings));
        return List.of(customStrings);
    }

    private String extractCustomDelimiter(String inputStrings) {
        return inputStrings.substring(SECOND_NUMBER, THIRD_NUMBER);
    }
~~~

해당 부분이 원인임을 찾음.

```//;\n1;2;3``` 값을 입력했을 때, ```//;\n1``` 부분이 같이 리스트에 담겨버림.

#### 해결

* 커스텀 구분자의 경우 //와 \n 사이에 어떤 값이 올지 모름. -> //와 \을 기준으로 분리 필요.
* \ 뒤에 숫자 부분 분리 필요

---

### 10/17

#### 문제점 & 분석

1. 빈값을 입력하는 경우 예외처리를 하지 않음.
2. 문자열이 "//"로 시작하면 커스텀 구분자 로직으로 넘어감 -> 커스텀 구분자 문자열 로직에는 "\\"를 이용하는 로직이 있음 -> "\\" 없다면 예외 발생시키도록 추가.

#### 해결

1. 빈 값 예외처리 진행

~~~
private void validateEmptyString(String inputStrings) {
        if (inputStrings.isEmpty()) {
            throw new IllegalArgumentException(EXCEPTION_EMPTY_STRING);
        }
    }
~~~

2. 커스텀 문자열이 "\\"를 포함하지 않을 경우 예외 처리 진행

~~~
private void validateCustomStrings(String inputStrings) {
    if (!inputStrings.contains(CUSTOM_NUMBER_DELIMITER)) {
        throw new IllegalArgumentException(EXCEPTION_STRING);
    }
}
~~~

---

#### 문제점 & 분석

~~~
if (!paresFirstString(inputStrings).equals(FIRST_CUSTOM_STRING)) {
            return parseStandardStrings(inputStrings);
        }
~~~

~~~
private String paresFirstString(String inputStrings) {
        return inputStrings.substring(INITIAL_NUMBER, SECOND_NUMBER);
    }
~~~

* 해당 로직을 하나로 합칠 수 있었다는 생각이 들었음. -> 가독성 향상

#### 해결

~~~
if (!inputStrings.startsWith(FIRST_CUSTOM_STRING)) {
            return parseStandardStrings(inputStrings);
        }
~~~

* startWith 를 사용하여 메서드를 통일하였음.

---

### 10/17

#### 문제점 & 분석

* application 예외 테스트를 진행하면서, 메서드별 단위 테스트를 안했다는 생각이 갑자기 들었음.
* 일급 컬렉션 형태도 아니고, 제대로된 원시값 포장 형태도 아님을 깨달았음.
* 메서드 별 단위 테스트를 할 수 있도록 로직 수정 필요.
* 모든 로직 수정 필요.
