# 수정 사항

### 10/16

#### 문제점

* ```//;\n1;2;3``` 값을 입력했을 때, ```NumberFormatException: 올바른 숫자 형식이 아닙니다.``` 예외처리 발생.

#### 분석

* StringParser 클래스

~~~
private List<String> parseCustomStrings(String inputStrings) {
        String[] customStrings = inputStrings.split(extractCustomDelimiter(inputStrings));
        return List.of(customStrings);
    }

    private String extractCustomDelimiter(String inputStrings) {
        return inputStrings.substring(SECOND_NUMBER, THIRD_NUMBER);
    }
~~~

해당 부분이 원인임을 찾음.

```//;\n1;2;3``` 값을 입력했을 때, ```//;\n1``` 부분이 같이 리스트에 담겨버림.

#### 해결

* 커스텀 구분자의 경우 //와 \n 사이에 어떤 값이 올지 모름. -> //와 \을 기준으로 분리 필요.
* \ 뒤에 숫자 부분 분리 필요

---

### 10/17

#### 문제점 & 분석

1. 빈값을 입력하는 경우 예외처리를 하지 않음.
2. 문자열이 "//"로 시작하면 커스텀 구분자 로직으로 넘어감 -> 커스텀 구분자 문자열 로직에는 "\\"를 이용하는 로직이 있음 -> "\\" 없다면 예외 발생시키도록 추가.

#### 해결

1. 빈 값 예외처리 진행

~~~
private void validateEmptyString(String inputStrings) {
        if (inputStrings.isEmpty()) {
            throw new IllegalArgumentException(EXCEPTION_EMPTY_STRING);
        }
    }
~~~

2. 커스텀 문자열이 "\\"를 포함하지 않을 경우 예외 처리 진행

~~~
private void validateCustomStrings(String inputStrings) {
    if (!inputStrings.contains(CUSTOM_NUMBER_DELIMITER)) {
        throw new IllegalArgumentException(EXCEPTION_STRING);
    }
}
~~~

---

### 10/17

#### 문제점 & 분석

~~~
if (!paresFirstString(inputStrings).equals(FIRST_CUSTOM_STRING)) {
            return parseStandardStrings(inputStrings);
        }
~~~

~~~
private String paresFirstString(String inputStrings) {
        return inputStrings.substring(INITIAL_NUMBER, SECOND_NUMBER);
    }
~~~

* 해당 로직을 하나로 합칠 수 있었다는 생각이 들었음. -> 가독성 향상

#### 해결

~~~
if (!inputStrings.startsWith(FIRST_CUSTOM_STRING)) {
            return parseStandardStrings(inputStrings);
        }
~~~

* startWith 를 사용하여 메서드를 통일하였음.

---

### 10/17

#### 문제점 & 분석

* application 예외 테스트를 진행하면서, 메서드별 단위 테스트를 안했다는 생각이 갑자기 들었음.
* 메서드 별 단위 테스트를 할 수 있도록 로직 수정 필요.
* 모든 로직 수정 필요.

#### 해결

* 먼저, 전체적인 기능 구현 목록을 수정하였다.


* StringParser
    * 생성자를 이용하여 값을 입력 받고, 그 값을 로직에 이용하였다.
  ~~~
  private final String inputStrings;

    public StringParser(String inputStrings) {
        validateEmptyString(inputStrings);
        this.inputStrings = inputStrings;
    }
  ~~~
    * 구분자를 추출하는 메서드를 생성하였다.
    * 구분자를 통해, 커스텀인지 기본구분자 경우인지 판별하여 리스트로 반환하는 메서드를 생성하였다.
    * ```public String extractDelimiter()```, ```public List<String> parseStrings(String delimiter)```
    * 내부 로직을 캡슐화 하였다.


* StringCalculator
    * 생성자를 이용하여 값을 입력 받고, 그 값을 로직에 이용하였다.
  ~~~
  private final List<String> numbers;

    public StringCalculator(List<String> numbers) {
        this.numbers = numbers;
    }
  ~~~
    * ```public int calculateStrings()``` 접근 지정자를 수정하였다.

**위 처럼 리팩토링 한 뒤 메서드 별 단위 테스트를 진행할 수 있게 되었다.**

---

### 10/18

#### 문제점 & 분석

* 과제 진행 요구사항에 ```기능을 구현하기 전 README.md에 구현할 기능 목록을 정리해 추가한다.``` 라는 요구사항이 있었다. -> REAMED.md 파일이 아닌 기능_구현_목록_정리.md 파일에 따로
  정리하였다.

#### 해결

* 해당 파일을 삭제하고, 기능 구현 목록 정리한 내용을 README.md 파일에 옮겨담았다.

---

### 10/19

#### 문제점 & 분석

* //?\\n1?2?3 과 같은 값이 들어왔을 때, ```PatternSyntaxException```이 발생한다.
* 정규표현식에 해당하는 메타문자는 일반 문자열로 읽어들일 수 없다는 오류를 알게되었음.
* 메타 문자(?, *, +, ., |, [, ], (, ), {, } 등)는 모두 오류를 발생시킬 수 있다는 사실을 알았음.

### 해결

* 정규표현식과 메타문자에 대해서 학습함

~~~
public String extractDelimiter() {
        if (!inputStrings.startsWith(FIRST_CUSTOM_STRING)) {
            return STANDARD_DELIMITER;
        }
        validateCustomStrings(inputStrings);
        return Pattern.quote(inputStrings.substring(SECOND_NUMBER, inputStrings.indexOf(CUSTOM_NUMBER_PART_DELIMITER)));
    }
~~~

* return 값에서 ```Pattern.quote()```를 사용하여 메타문자를 일반 문자열로 받아들일 수 있게 하였다.

---

### 10/20

#### 문제점 & 분석

* **InputView**

~~~
public String getString(){
        System.out.println("덧셈할 문자열을 입력해 주세요.");
        return Console.readLine();
    }
~~~

* InputView 에서는 입력만 받는 책임을 가져야 하는데, 출력을 하는 문제점을 찾음.

#### 해결

* OutputView

~~~
public void getString() {
        System.out.println("덧셈할 문자열을 입력해 주세요.");
    }
~~~

* InputView

~~~
public String getString() {
        return Console.readLine();
    }
~~~

* 위와 같은 형식으로 메서드를 나눠서 책임에 관한 문제를 해결함.
* OutputView, InputView 수정에 따라, 컨트롤러도 수정함.

---

### 10/21

#### 문제점 & 분석

* 들어올 수 있는 문자열을 더 분석하여서 예외를 처리하고자 하였음.

##### 들어올 수 있는 문자열 : [기본 구분자]

* 빈 값 -> StringParser 에서 예외처리(처리 완료)
* 1,2;3 기본 구분자 형식 -> 정상 동작(처리 완료)
* 1,-2;3 음수가 포함된 형식 -> StringCalculator 에서 예외처리(처리 완료)
* 1,,2;3 연속된 구분자가 포함된 형식 -> StringCalculator 에서 예외처리(처리 완료)
* 1,2?3 기본 구분자가 아닌 형식 -> StringCalculator 에서 예외처리(처리 완료)
* 1,2,a 형식에 다른 문자가 포함된 경우 -> StringCalculator 에서 예외처리(처리 완료)
* 1,2,3,, 마지막이 기본 구분자가 붙는 경우 -> 정상출력되어짐. 예외처리 필요(처리 미완료 -> 완료)

##### 들어올 수 있는 문자열 : [커스텀 구분자]

* 빈 값 -> StringParser 에서 예외처리(처리 완료)
* //;\1;2;3 완성되지 않은 형식 -> "\\" 혹은 "/"가 빠질 경우 StringParser 에서 예외처리(처리완료), 다른 문자의 경우 StringCalculator 에서 예외처리(처리완료)
* //;\n1;2;3 단일 구분자 형식 -> 정상 동작(처리 완료)
* //;;\n1;;2;;3 연속된 구분자 형식 -> 정상 동작(처리 완료)
* //?\n1?2?3 메타 문자가 구분자인 형식 -> 정상동작(처리 완료)
* //;\n1;;2;;3 연속된 구분자가 숫자 부분에 포함된 형식 -> StringCalculator 에서 예외처리(처리 완료)
* //;\n1;-2;3 음수가 포함된 형식 -> StringCalculator 에서 예외처리(처리 완료)
* //1\n1;2;3 구분자가 숫자인 형식 -> StringCalculator 에서 예외처리(처리 완료)
* //\n1;2;3 구분자가 없는 경우 -> StringCalculator 에서 예외처리(처리 완료)
* 1//;\n1;2;3 형식 앞에 숫자가 있는 경우 -> StringCalculator 에서 예외처리 (처리 완료)
* //;\n1?2?3 구분자가 아닌 문자로 나눠진 경우 -> StringCalculator 에서 예외처리 (처리 완료)
* //;\n1;2;3;a 마지막에 다른 문자가 붙는 경우 -> StringCalculator 에서 예외처리 (처리 완료)
* //;\n1;2;3;; 마지막에 구분자가 붙는 경우 -> 정상출력되어짐. 예외처리 필요(처리 미완료 -> 완료)

**현재 마지막에 구분자가 붙는 경우에 정상출력되어진다는 문제점을 발견하였음.**

#### 해결

* 마지막에 구분자가 포함되는 경우 예외가 발생하도록 하였음.
* 또한, 들어오는 입력에 대하여 바로 검층 처리를 하고자 하였음. -> 왜냐하면 현재 StringParser 클래스에 검증 로직이 있는데, 검증 로직을 따로 구분하여 관심사를 분리하고자 하였음.
* 검증 로직 분리 해결 방안 -> 원시값 포장: InputNumbers 로 String inputString 을 원시값 포장하여 사용.

**InputNumber**

~~~
package calculator.domain;

public class InputNumber {

    private static final String EXCEPTION_EMPTY_STRING = "빈 값을 입력하셨습니다.";
    private static final String EXCEPTION_CUSTOM_STRING = "올바른 형식으로 입력하세요.";
    private static final String CUSTOM_NUMBER_PART_DELIMITER = "\\";

    private final String inputStrings;

    public InputNumber(String inputStrings) {
        validateEmptyString(inputStrings);
        validateLastIndex(inputStrings);
        validateCustomStrings(inputStrings);
        this.inputStrings = inputStrings;
    }

    public String getInputStrings() {
        return inputStrings;
    }

    private void validateEmptyString(String inputStrings) {
        if (inputStrings.isEmpty()) {
            throw new IllegalArgumentException(EXCEPTION_EMPTY_STRING);
        }
    }

    private void validateCustomStrings(String inputStrings) {
        if (!inputStrings.contains(CUSTOM_NUMBER_PART_DELIMITER)) {
            throw new IllegalArgumentException(EXCEPTION_CUSTOM_STRING);
        }
    }

    private void validateLastIndex(String inputStrings) {
        if (!Character.isDigit(inputStrings.charAt(inputStrings.length() - 1))) {
            throw new IllegalArgumentException(EXCEPTION_CUSTOM_STRING);
        }
    }
}
~~~

---

### 10/21

#### 문제점 & 분석

**InputNumber**

* 현재 코드

~~~
public InputNumber(String inputStrings) {
        validateEmptyString(inputStrings);
        validateLastIndex(inputStrings);
        validateCustomStrings(inputStrings);
        this.inputStrings = inputStrings;
    }

private void validateCustomStrings(String inputStrings) {
        if (!inputStrings.contains(CUSTOM_NUMBER_PART_DELIMITER)) {
            throw new IllegalArgumentException(EXCEPTION_CUSTOM_STRING);
        }
    }
~~~

* 테스트 코드 작성 중, 기본 구분자인 경우(1,2;3) 입력하였을 때, 오류 발생.
* 위와 같이 원시값 포장하여, 커스텀 구분자가 아닌 경우는 모두 오류가 발생함.
* 너무 생각없이 코드를 작성하였다는 생각이 들었음.

#### 해결

~~~
public InputNumber(String inputStrings) {
        validateEmptyString(inputStrings);
        validateLastIndex(inputStrings);
        validateCustomStrings(inputStrings);
        this.inputStrings = inputStrings;
    }

private void validateCustomStrings(String inputStrings) {
        if (inputStrings.startsWith(FIRST_CUSTOM_STRING)) {
            validateCustomDelimiter(inputStrings);
        }
    }

    private void validateCustomDelimiter(String inputStrings) {
        if (!inputStrings.contains(CUSTOM_NUMBER_PART_DELIMITER)) {
            throw new IllegalArgumentException(EXCEPTION_CUSTOM_STRING);
        }
    }
~~~

* 커스텀 구분자 형식으로 시작될 때만, 커스텀 구분자 delimiter 값을 가지고 있는지 검증하는 메서드를 만듬

